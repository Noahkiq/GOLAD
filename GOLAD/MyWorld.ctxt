#BlueJ class context
comment0.target=MyWorld
comment0.text=\r\n\ Write\ a\ description\ of\ class\ MyWorld\ here.\r\n\ \r\n\ @author\ (your\ name)\ \r\n\ @version\ (a\ version\ number\ or\ a\ date)\r\n
comment1.params=
comment1.target=MyWorld()
comment1.text=\r\n\ Constructor\ for\ objects\ of\ class\ MyWorld.\r\n\ \r\n
comment10.params=times\ board
comment10.target=void\ iterate(int,\ Tile[][])
comment11.params=
comment11.target=void\ updateNumbers()
comment12.params=
comment12.target=void\ sandboxTurn()
comment13.params=
comment13.target=void\ drawTime()
comment14.params=filename\ board
comment14.target=void\ writeBoard(java.lang.String,\ Tile[][])
comment15.params=filename
comment15.target=void\ readBoard(java.lang.String)
comment16.params=
comment16.target=void\ displayMoves()
comment17.params=
comment17.target=void\ drawRules()
comment18.params=
comment18.target=void\ newBoard()
comment19.params=
comment19.target=void\ clearBoard()
comment2.params=
comment2.target=void\ act()
comment20.params=
comment20.target=void\ killAll()
comment21.params=
comment21.target=void\ playGame()
comment22.params=
comment22.target=void\ sandbox()
comment23.params=
comment23.target=void\ getRules()
comment24.params=color\ img
comment24.target=void\ setBrush(int,\ greenfoot.GreenfootImage)
comment25.params=
comment25.target=void\ saveTiles()
comment26.params=
comment26.target=void\ tutorial()
comment27.params=
comment27.target=void\ tutorial2()
comment28.params=
comment28.target=void\ tutorial3()
comment29.params=
comment29.target=void\ tutorial4()
comment3.params=
comment3.target=void\ playerSelect()
comment30.params=turnNumber
comment30.target=void\ setTurn(int)
comment30.text=public\ double\ getFutureRatio(int[]\ square,\ int\ depth,\ Tile[][]\ board){\r\n\ \ \ \ \ \ \ \ Tile\ toKill\ \=\ board[square[0]][square[1]];\r\n\ \ \ \ \ \ \ \ double\ redCount\ \=\ 0;\r\n\ \ \ \ \ \ \ \ double\ blueCount\ \=\ 0;\r\n\ \ \ \ \ \ \ \ toKill.isRed\ \=\ false;\r\n\ \ \ \ \ \ \ \ toKill.isBlue\ \=\ false;\r\n\ \ \ \ \ \ \ \ toKill.isDead\ \=\ true;\r\n\ \ \ \ \ \ \ \ toKill.updateNeighbours(board);\r\n\ \ \ \ \ \ \ \ //writeBoard("before.txt",\ board);\r\n\ \ \ \ \ \ \ \ iterate(depth,\ board);\r\n\ \ \ \ \ \ \ \ //writeBoard("after.txt",\ board);\r\n\ \ \ \ \ \ \ \ for(Tile[]\ ts\:board){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(Tile\ t\:ts){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(t.isRed){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ redCount++;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }else\ if(t.isBlue){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ blueCount++;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ if(blueCount\=\=0){\r\n\ \ \ \ \ \ \ \ \ \ \ \ return\ 2147483647;\r\n\ \ \ \ \ \ \ \ }else{\r\n\ \ \ \ \ \ \ \ \ \ \ \ return\ redCount/blueCount;\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ }\r\n\ \ \ \ public\ boolean\ checkForSquares(){\r\n\ \ \ \ \ \ \ \ ArrayList<Tile>\ sacraficeList\ \=\ new\ ArrayList<Tile>();\r\n\ \ \ \ \ \ \ \ int\ x\=0;\r\n\ \ \ \ \ \ \ \ int\ y\=0;\r\n\ \ \ \ \ \ \ \ findSquare\:\r\n\ \ \ \ \ \ \ \ for(x\=0;\ x<20;\ x++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(y\=0;\ y<20;\ y++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toCheck\ \=\ allTiles[x][y];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if((toCheck.isBlue\ &&\ redTurn)\ ||\ (toCheck.isRed\ &&\ blueTurn)){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int\ state\=toCheck.getState();\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ try{\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(allTiles[x+1][y].getState()\=\=state\ &&\ allTiles[x+1][y+1].getState()\=\=state\ &&\ allTiles[x][y+1].getState()\=\=state){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break\ findSquare;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }catch(Exception\ e){}\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(x\=\=19\ &&\ y\=\=\ 19){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ findEasySacrafices\:\r\n\ \ \ \ \ \ \ \ for(int\ x2\=0;\ x2<20;\ x2++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(int\ y2\=0;\ y2<20;\ y2++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toCheck\ \=\ allTiles[x2][y2];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(((toCheck.isRed\ &&\ redTurn)\ ||\ (toCheck.isBlue\ &&\ blueTurn))\ &&\ toCheck.willDie){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacraficeList.add(toCheck);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(sacraficeList.size()\=\=2){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break\ findEasySacrafices;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ if(sacraficeList.size()<2){\r\n\ \ \ \ \ \ \ \ \ \ \ \ findOtherSacrafices\:\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(int\ x2\=0;\ x2<20;\ x2++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(int\ y2\=0;\ y2<20;\ y2++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toCheck\ \=\ allTiles[x2][y2];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int[]\ neighbours\ \=\ toCheck.getNeighbourCount(allTiles);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int\ neighbourCount\ \=\ neighbours[0]+neighbours[1]+neighbours[2];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ArrayList<Tile>\ neighbourList\ \=\ toCheck.getNeighbours(allTiles);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(Tile\ t\:neighbourList){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(sacraficeList.contains(t)){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ neighbourCount--;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(((toCheck.isRed\ &&\ redTurn)\ ||\ (toCheck.isBlue\ &&\ blueTurn))\ &&\ neighbourCount\=\=3){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacraficeList.add(toCheck);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(sacraficeList.size()\=\=2){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break\ findOtherSacrafices;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ if(sacraficeList.size()<2){\r\n\ \ \ \ \ \ \ \ \ \ \ \ return\ false;\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ for(Tile\ t\:sacraficeList){\r\n\ \ \ \ \ \ \ \ \ \ \ \ t.isBlue\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ t.isRed\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ t.isDead\=true;\r\n\ \ \ \ \ \ \ \ \ \ \ \ t.preupdate(allTiles);\r\n\ \ \ \ \ \ \ \ \ \ \ \ t.updateNeighbours(allTiles);\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ for(int\ x2\=-1;\ x2<\=2;\ x2++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(int\ y2\=-1;\ y2<\=2;\ y2++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if((x2>-1\ &&\ x2<2\ &&\ (y2\=\=-1\ ||\ y2\=\=2))||\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (y2>-1\ &&\ y2<2\ &&\ (x2\=\=-1\ ||\ x2\=\=2))){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ try{\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toSummon\ \=\ allTiles[x+x2][y+y2];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ toSummon.isRed\ \=\ redTurn;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ toSummon.isBlue\ \=\ blueTurn;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ toSummon.isDead\ \=\ false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ toSummon.preupdate(allTiles);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ toSummon.updateNeighbours(allTiles);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ true;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }catch(Exception\ e){}\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ return\ false;\r\n\ \ \ \ }\r\n\ \ \ \ public\ boolean\ squareCrawl(){\ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ int\ redX\=0;\r\n\ \ \ \ \ \ \ \ int\ redY\=0;\r\n\ \ \ \ \ \ \ \ int\ blueX\=0;\r\n\ \ \ \ \ \ \ \ int\ blueY\=0;\r\n\ \ \ \ \ \ \ \ findRedSquare\:\r\n\ \ \ \ \ \ \ \ for(redX\=0;\ redX<20;\ redX++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(redY\=0;\ redY<20;\ redY++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toCheck\ \=\ allTiles[redX][redY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(toCheck.isRed){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int\ state\=toCheck.getState();\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ try{\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(allTiles[redX+1][redY].getState()\=\=state\ &&\ allTiles[redX+1][redY+1].getState()\=\=state\ &&\ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allTiles[redX][redY+1].getState()\=\=state\ &&\ allTiles[redX][redY-1].getState()\=\=0\ &&\ allTiles[redX+1][redY-1].getState()\=\=0\ &&\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allTiles[redX-1][redY].getState()\=\=0\ &&\ allTiles[redX-1][redY+1].getState()\=\=0\ &&\ allTiles[redX][redY+2].getState()\=\=0\ &&\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allTiles[redX+1][redY+2].getState()\=\=0\ &&\ allTiles[redX+2][redY+1].getState()\=\=0\ &&\ allTiles[redX+2][redY].getState()\=\=0){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break\ findRedSquare;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }catch(Exception\ e){}\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(redX\=\=19\ &&\ redY\ \=\=\ 19){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ findBlueSquare\:\r\n\ \ \ \ \ \ \ \ for(blueX\=0;\ blueX<20;\ blueX++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(blueY\=0;\ blueY<20;\ blueY++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toCheck\ \=\ allTiles[blueX][blueY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(toCheck.isBlue){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int\ state\=toCheck.getState();\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ try{\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(allTiles[blueX+1][blueY].getState()\=\=state\ &&\ allTiles[blueX+1][blueY+1].getState()\=\=state\ &&\ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allTiles[blueX][blueY+1].getState()\=\=state\ &&\ allTiles[blueX][blueY-1].getState()\=\=0\ &&\ allTiles[blueX+1][blueY-1].getState()\=\=0\ &&\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allTiles[blueX-1][blueY].getState()\=\=0\ &&\ allTiles[blueX-1][blueY+1].getState()\=\=0\ &&\ allTiles[blueX][blueY+2].getState()\=\=0\ &&\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allTiles[blueX+1][blueY+2].getState()\=\=0\ &&\ allTiles[blueX+2][blueY+1].getState()\=\=0\ &&\ allTiles[blueX+2][blueY].getState()\=\=0){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ break\ findBlueSquare;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }catch(Exception\ e){}\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(blueX\=\=19\ &&\ blueY\ \=\=\ 19){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return\ false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ Tile\ sacrafice1\=null;\r\n\ \ \ \ \ \ \ \ Tile\ sacrafice2\=null;\r\n\ \ \ \ \ \ \ \ Tile\ summon\=null;\r\n\ \ \ \ \ \ \ \ if(redY-blueY>2){\r\n\ \ \ \ \ \ \ \ \ \ \ \ if(redTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[redX][redY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[redX+1][redY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[redX][redY-1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }else\ if(blueTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[blueX][blueY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[blueX+1][blueY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[blueX][blueY+2];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }else\ if(redY-blueY<-2){\r\n\ \ \ \ \ \ \ \ \ \ \ \ if(redTurn){\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[redX][redY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[redX+1][redY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[redX][redY+2];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }else\ if(blueTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[blueX][blueY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[blueX+1][blueY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[blueX][blueY-1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }else\ if(redX-blueX<0){\r\n\ \ \ \ \ \ \ \ \ \ \ \ if(redTurn){\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[redX][redY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[redX][redY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[redX+2][redY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }else\ if(blueTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[blueX+1][blueY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[blueX+1][blueY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[blueX-1][blueY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }else\ if(redX-blueX>0){\r\n\ \ \ \ \ \ \ \ \ \ \ \ if(redTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[redX+1][redY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[redX+1][redY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[redX-1][redY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }else\ if(blueTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice1\=allTiles[blueX][blueY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sacrafice2\=allTiles[blueX][blueY+1];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon\=allTiles[blueX+2][blueY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ if(sacrafice1\ \!\=\ null\ &&\ sacrafice2\ \!\=null\ &&\ summon\ \!\=null){\r\n\ \ \ \ \ \ \ \ \ \ \ \ sacrafice1.isRed\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ sacrafice1.isBlue\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ sacrafice1.isDead\=true;\r\n\ \ \ \ \ \ \ \ \ \ \ \ sacrafice2.isRed\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ sacrafice2.isBlue\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ sacrafice2.isDead\=true;\r\n\ \ \ \ \ \ \ \ \ \ \ \ summon.isDead\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ if(redTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon.isBlue\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon.isRed\=true;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }else\ if(blueTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon.isBlue\=true;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summon.isRed\=false;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ sacrafice1.preupdate(allTiles);\r\n\ \ \ \ \ \ \ \ sacrafice1.updateNeighbours(allTiles);\r\n\ \ \ \ \ \ \ \ sacrafice2.preupdate(allTiles);\r\n\ \ \ \ \ \ \ \ sacrafice2.updateNeighbours(allTiles);\r\n\ \ \ \ \ \ \ \ summon.preupdate(allTiles);\r\n\ \ \ \ \ \ \ \ summon.updateNeighbours(allTiles);\r\n\ \ \ \ \ \ \ \ return\ true;\r\n\ \ \ \ }\r\n\ \ \ \ public\ void\ makeMove(int\ depth){\r\n\ \ \ \ \ \ \ \ if(depth\ \=\=\ 0){\r\n\ \ \ \ \ \ \ \ \ \ \ \ makeRandomMove();\r\n\ \ \ \ \ \ \ \ \ \ \ \ return;\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ double[]\ move\ \=\ {0,0,0};\r\n\ \ \ \ \ \ \ \ Tile[][]\ board\ \=\ new\ Tile[20][20];\r\n\ \ \ \ \ \ \ \ if(blueTurn){\r\n\ \ \ \ \ \ \ \ \ \ \ \ move\=new\ double[]{0,0,2147483647};\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ for(int\ x\ \=\ 0;\ x\ <\ 20;\ x++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(int\ y\ \=\ 0;\ y\ <\ 20;\ y++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toAdd\ \=\ new\ Tile(this,\ x,\ y);\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ board[x][y]\=toAdd;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ for(int\ x\=0;\ x<20;\ x++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ for(int\ y\=0;\ y<20;\ y++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if(allTiles[x][y].getState()\=\=1||allTiles[x][y].getState()\=\=2){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int[]\ coords\ \=\ {x,y};\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(int\ tileX\=0;\ tileX<20;\ tileX++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ for(int\ tileY\=0;\ tileY<20;\ tileY++){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ newTile\ \=\ board[tileX][tileY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Tile\ toClone\ \=\ allTiles[tileX][tileY];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newTile.isRed\ \=\ toClone.isRed;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newTile.isBlue\ \=\ toClone.isBlue;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newTile.isDead\ \=\ toClone.isDead;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newTile.willDie\ \=\ toClone.willDie;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newTile.willRed\ \=\ toClone.willRed;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newTile.willBlue\ \=\ toClone.willBlue;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ double[]\ newMove\ \=\ new\ double[3];\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newMove[0]\=x;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newMove[1]\=y;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if((reds.size()+blues.size())<16){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newMove[2]\=getFutureRatio(coords,\ 2,\ board);\ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }else{\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ newMove[2]\=getFutureRatio(coords,\ depth,\ board);\ \ \ \ \ \ \ \r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ if((redTurn\ &&\ newMove[2]>move[2])||(blueTurn\ &&\ newMove[2]<move[2])){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ move\ \=\ newMove;\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ if(((reds.size()/blues.size())\ \=\=\ move[2])\ &&\r\n\ \ \ \ \ \ \ \ \ \ \ (redTurn\ &&\ redDepth\ \=\=\ 4\ &&\ ((blues.size()\ %\ 4)\=\=0)\ &&\ blues.size()\=\=4\ &&\ reds.size()\=\=4)||\r\n\ \ \ \ \ \ \ \ \ \ \ (blueTurn\ &&\ blueDepth\ \=\=\ 4\ &&\ ((reds.size())\ %\ 4\=\=0)\ &&\ reds.size()\=\=4\ &&\ blues.size()\=\=4)){\r\n\ \ \ \ \ \ \ \ \ \ \ \ if(squareCrawl()){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ if(((reds.size()/blues.size())\ \=\=\ move[2])\ &&\r\n\ \ \ \ \ \ \ \ \ \ \ (redTurn\ &&\ redDepth\ \=\=\ 4\ &&\ ((blues.size()\ %\ 4)\=\=0)\ &&\ blues.size()<\=12\ &&\ reds.size()>4)||\r\n\ \ \ \ \ \ \ \ \ \ \ (blueTurn\ &&\ blueDepth\ \=\=\ 4\ &&\ ((reds.size())\ %\ 4\=\=0)\ &&\ reds.size()<\=12\ &&\ blues.size()>4)){\r\n\ \ \ \ \ \ \ \ \ \ \ \ if(checkForSquares()){\r\n\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ return;\r\n\ \ \ \ \ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ Tile\ toMove\ \=\ allTiles[(int)move[0]][(int)move[1]];\r\n\ \ \ \ \ \ \ \ toMove.isRed\ \=\ false;\r\n\ \ \ \ \ \ \ \ toMove.isBlue\ \=\ false;\r\n\ \ \ \ \ \ \ \ toMove.isDead\ \=\ true;\r\n\ \ \ \ \ \ \ \ toMove.preupdate(allTiles);\r\n\ \ \ \ \ \ \ \ toMove.updateNeighbours(allTiles);\r\n\ \ \ \ }\r\n\ \ \ \ public\ void\ makeRandomMove(){\r\n\ \ \ \ \ \ \ \ int\ tileX\ \=\ Greenfoot.getRandomNumber(20);\r\n\ \ \ \ \ \ \ \ int\ tileY\ \=\ Greenfoot.getRandomNumber(20);\r\n\ \ \ \ \ \ \ \ Tile\ t\ \=\ allTiles[tileX][tileY];\r\n\ \ \ \ \ \ \ \ while(\!((t.isBlue\ &&\ redTurn)||(t.isRed\ &&\ blueTurn))){\r\n\ \ \ \ \ \ \ \ \ \ \ \ tileX\ \=\ Greenfoot.getRandomNumber(20);\r\n\ \ \ \ \ \ \ \ \ \ \ \ tileY\ \=\ Greenfoot.getRandomNumber(20);\r\n\ \ \ \ \ \ \ \ \ \ \ \ t\ \=\ allTiles[tileX][tileY];\r\n\ \ \ \ \ \ \ \ }\r\n\ \ \ \ \ \ \ \ t.isRed\=false;\r\n\ \ \ \ \ \ \ \ t.isBlue\=false;\r\n\ \ \ \ \ \ \ \ t.isDead\=true;\r\n}
comment31.params=
comment31.target=java.lang.String\ test()
comment4.params=
comment4.target=void\ mainMenu()
comment5.params=
comment5.target=void\ createGrid()
comment6.params=board
comment6.target=void\ iterate(Tile[][])
comment7.params=
comment7.target=void\ updateLists()
comment8.params=
comment8.target=void\ doTurn()
comment9.params=
comment9.target=void\ randomizeGrid()
numComments=32
